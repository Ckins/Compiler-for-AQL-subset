A Detailed Document of aql_master


DocToken:
records the info of every token in an article:
# int start_pos_   : the token's start position in the article
# int end_pos_     : the token's start position in the article
# string content_  ï¼šthe content of the token
# int word_num_    : the NO. of the token (the first token int the article is 1)


Tokenizer:
records an article and cut it into DocTokens:
# int word_num_                     : the quantity of tokens in the article
# vector<DocToken> doc_vector_      : a vector recording all tokens of the article
# string file_name_                 : the name of the article
# whole_string_                     : the whole article in string

* void make_token()                            : handle the article from the beginning 
* void display() const                         : show all tokens and its No.
* vector<DocToken> get_doc_token_list() const  : get all tokens in vector
* bool is_num_or_letter(char&)               : judge whether a char is a num or letter
* string get_all_as_string() const             : returns the whole article in string


Code
Tag:
records all reserved words adn data types of the AQL


CodeToken:
records the info of every token in a AQL code:
# int tag_         : the Tag of the token
# int line_        : the line num of the token (used in error handling)
# int num_value_   : if the token is a num, num_value_ will record its value (while  lexme_ will be assigned "")
# string lexme_    : if the token is a string, lexme_ will record its content (while num_value will be assigned -999)

* void set(CodeToken*, CodeToken*)     : deeply copy the second para to the first
* CodeToken& operator=(const)          : deeply copy the second para to the first (it will call methos(set))
* string toString()                    : retrun the token in string


Span:
records the info of a span
# int start_pos_                    : the span's start position in the article
# int end_pos_                      : the span's end position in the article
# string value_                     : the content of the span
# vector<int> pattern_col_marks     : 
# int word_start_pos_               : a span may include more than one token, so this variable records the No. of the first token in the span
# int word_end_pos_                 : it records the No. of the last token in the span

* void display()                 : print the span
* bool operator==(const Span&)     : judge if two span are same (having same start_pos_ and end_pos_)


GroupRecord:
records the info of a group (this is a redundant copy, because it is also recorded in class PatternGroup)
# int group_num_      : the No. of the group (0 means the whole pattern)
# string column_id_   : the name of the group


Atom:
records the info of a column (this is similiar to class column, but we use this in pattern)
# int type_            : the type(Tag) of the column (including regex, a column of a view and token)
# int repeat_min_      : the min repeat time (the first num in a {n, m})
# int repeat_max_      : the max repeat time (the second num in a {n, m})
# string view_alias_   : the alias of the atom
# string col_name_     : the name of the atom
# string regex_expr_   : if the atom is a regex, it records the regular expression


PatternGroup:
records the detailed info of a group (surrounded by a pair of paren)
# int group_num_                  : the No. of the group
# string column_id_               : the name of the group
# int start_col_seq_              : the No. of the start atom of the group (begin with 0, from left to right in the AQL)
# int end_col_seq_                : the No. of the end atom of the group
# vector<Atom> content_atoms_     : all atoms of the group


Column:
records the info of a column
# vector<Span> span_list_   : all spans of the column
# string col_name_          : the name of the column
# int col_width_            : the max width of the column (uesd in print)

* vector<Span> get_span_list()  : returns all spans of the column
* string get_name()             : returns the name of the column
* void set_name(string)         : set a name to the column
* void add_span(Span)           : add a span to the column
* void set_list(vector<Span>)   : set a span list to the column (drop the original one)
* int calculate_col_width()     : calculate the max length of all spans in the column
* int get_col_width()           : returns the max length of the column
* string to_string(int)         : conver a num to a string


View:
records the info of a view
# vector<Column> column_list_    : all columns of the view
# string view_name_              : the name of the view
# string view_alias              : the alial of the view

* vector<Column> get_column_list()     : returns all columns of the view
* void add_column(Column)              : add a column to the view
* void set_list(vector<Column>)        : set a column list to the view (drop the original one)
* void set_alias(string name)          : set a alias to the view
* string get_name()                    : returns the name of the view
* string get_alias()                   : returns the alias of the view
* Column get_column_by_name(string)    : returns a column of the view with a given name
* int calculate_row_num()              : calculate the max size of spans of all columns (used in print)
* bool is_empty()                      : judge if all columns are empty (uesd in print)


Lexer:
cut an AQL into tokens
# static int line_                         : the No. of reading line
# string file_                             : the name of the file
# char peek_                               : the handling char
# bool is_end_                             : it will be true if reaches the EOF
# std::ifstream instream_                  : the ifstream of the file
# map<string, CodeToken> words_            : the reserved words
# vector<CodeToken> code_token_list_       : records all tokens of the given AQL

* void readch()                            : move to the next char 
* void reserve(CodeToken)                  : handle reserved words
* bool is_letter(char)                     : judge whether the char is a letter
* bool is_letter_or_num(char)              : judge whether the char is a letter or a num
* CodeToken scan()                         : get the next token
* vector<CodeToken> get_list()             : returns all tokens of the given AQL


Parser:
